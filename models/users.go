package models

import (
	"errors"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	// ErrorNotFound is returned when a user is not found in the database.
	ErrorNotFound = errors.New("models: user not found")
)

var (
	// ErrInvalidID is returned when an invalid ID is provided.
	ErrInvalidID = errors.New("models: provided ID is invalid")
)

type User struct {
	gorm.Model
	Name  string
	Email string `gorm:"not null;unique_index"`
}

type UserService struct {
	db *gorm.DB
}

func NewUserService(connectionInfo string) (*UserService, error) {
	db, err := gorm.Open(postgres.Open(connectionInfo), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})
	if err != nil {
		return nil, err
	}
	return &UserService{
		db: db,
	}, nil
}

func (us *UserService) Close() error {
	sqlDB, err := us.db.DB()
	if err != nil {
		panic(err)
	}
	return sqlDB.Close()
}

// ByID will look up a user with the provided ID.
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with
// more information about what went wrong. This may not be
// an error generated by the models package.
//
// As a general rule, any error but ErrNotFound should
// probably result in a 500 error.

func (us *UserService) ByID(id uint) (*User, error) {
	var user User
	db := us.db.Where("id = ?", id)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

func (us *UserService) DestructiveReset() error {
	if err := us.db.Migrator().DropTable(&User{}); err != nil {
		return err
	}
	return us.AutoMigrate()
}

func (us *UserService) Create(user *User) error {
	return us.db.Create(user).Error
}

func first(db *gorm.DB, dest any) error {
	err := db.First(dest).Error
	if err == gorm.ErrRecordNotFound {
		return ErrorNotFound
	}
	return err
}

// ByEmail looks up a user with the given email address and
// returns that user.
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with
// more information about what went wrong. This may not be
// an error generated by the models package.

func (us *UserService) ByEmail(email string) (*User, error) {
	var user User
	db := us.db.Where("email = ?", email)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (us *UserService) Update(user *User) error {
	return us.db.Save(user).Error
}

// Deleting a user is a little trickier, because GORM’s delete method works in one of two ways. The first is what we would normally expect. If we provide GORM with a user object that has an ID GORM will only delete a user with the same primary key.

// The second is a bit trickier. If we DO NOT provide an ID (eg it is 0), then GORM will delete ALL users. We aren’t ever going to do this, so we are going to write a bit of code to prevent this from accidentally happening. We will start with an error for when the ID provided is invalid.

func (us *UserService) Delete(id uint) error {
	if id == 0 {
		return ErrInvalidID
	}
	user := User{Model: gorm.Model{ID: id}}
	return us.db.Delete(&user).Error
}

// AutoMigrate will attempt to automatically migrate the
// users table
func (us *UserService) AutoMigrate() error {
	if err := us.db.AutoMigrate(&User{}); err != nil {
		return err
	}
	return nil
}
